В этом файле я планирую сохранять важную информацию (ключевые решения, выводы), к которой агент может обращаться по мере необходимости.

я не уверен, в каком финальном виде будут использоваться результаты текущей разработки, но мне нужно проверить пару теорий про анализ и юикс.
Итак, задача. Активити вотч собирает статистику и я хочу ее анализировать.
Есть три основных бакета: aw-watcher-window, aw-watcher-afk, aw-stopwatch. Второстепенные (aw-watcher-vscode, aw-watcher-input, aw-watcher-systeminfo) мне пока не интересны, но суть аналогична и их добавление должно быть простым в будущем.
Вотчеры трех основных бакетов собирают ивенты в естественной форме: их начало и конец определены натуральным образом. Мне же нужно дробить и агрегировать.

Например, мне может понадобиться видеть данные за определенный час. Но некоторые ивенты длятся дольше. Если ивент начался до часа Икс, то я хочу видеть лишь соответствующую долю продолжительности. Значит нужно дробить все ивенты дня на 24 группы длиной по часу.
Второй пример: я начинаю день (пробуждаю комп из гибернации) в условные 8 часов утра. В этот момент актвити вотч завершает ивент афк, который начат вчера за некоторое время до гибернации, и начинает новый ивент Нот-афк. Так вот, очень важно в итоговый вывод помещать время начала и конца рабочего дня (начало первого и конец последнего нотафк ивента). Эта границы должны быть использованы в том числе и в разбиении ивентов виндоу и стопвотч. если всю ночь на компе был активен например рабочий стол или иное окно, время от полуночи до начала моего рабочего дня не должно попасть в результат.
Итого у нас уже есть два набора для дробления: по часам и по попаданию в рабочий день. Но есть и третий: ивенты стопвотч это задачи, такие как Работа над проектом А, кодинг фичи Б и тому подобное. И надо разбивать ивенты виндоу еще и по задачам, тк мне может понадобиться увидеть, как долго было актвно окно Икс в задаче А.
Я не знаю, какую архитектуру выбрать. Вижу две опиции:
1. Единый список мелко порубленных ивентов бакета, разбитый не только по часам, но и по границам задач.
2. Два или три списка: 
	- ивенты, разбтые по часам
	- ивенты, разбтые по задачам
	- ивенты, разбтые по попаданию в рабочий день.

Очевидно, нужна и последующая агрегация, когда я хочу увидеть сумму продолжительностей ивентов за определенный час, день, месяц или за задачу.

кажется я понял что нужно. мне не нужна сложная агрегация по часам и по задачам одновременно, это будут две независимых формы отображения статистики. нужно два списка а точнее объекта.
первый это по времени:
время: ивенты виндоу и ивенты стопвотч (эта форма нужна если нужно понять что я делал)
второй по стопвотчу
задача: время: ивенты виндоу (эта форма нужна для анализа, чем была заполнена задача)
где
время - это вложенные год, месяц, неделя, день, час.
задача - это ивент стопвотч

при этом всем нужно учитывать лишь время нот-афк. нужно фильтровать и обрезать ивенты виндоу и стопвотч по ивентам афк.

думаю надо представить день так: делаем не один таймлайн, а вертикальный стек из 24 таймлайнов, но на самом деле меньше, тк часы без активности мы не будем показывать. вторым приоритетом надо сделать календарный вид месяца, где будем отображать статистику каждого дня: время начала и конца работы, две продолжительности дня - нот-афк и грязная, число задач, названия задач и их продолжительности (тоже грязная и чистая), число окон, названия окон и их продолжительности, почасовая активность (до 24 величин от 0 до 60 минут). как думаешь?

---

# Итоговая спецификация обработки данных

# Спецификация обработки данных ActivityWatch

## 1. Цель

Проанализировать данные из ActivityWatch, преобразовав их в две структурированные модели для дальнейшей визуализации и анализа.

## 2. Входные данные

- `aw-watcher-afk.json`: события статуса пользователя (afk, not-afk).
- `aw-watcher-window.json`: события активного окна приложения.
- `aw-stopwatch.json`: события таймера задач, определяемые пользователем.

## 3. Ключевая логика: Фильтрация по активности (AFK)

Это основной и самый важный этап обработки.

1.  Из `aw-watcher-afk.json` формируется список всех временных интервалов, когда пользователь имел статус **`not-afk`**. Эти интервалы представляют "активное время".
2.  Каждое событие из `aw-watcher-window.json` и `aw-stopwatch.json` должно быть отфильтровано и обрезано в соответствии с интервалами "активного времени".
3.  Если событие (например, использование приложения) пересекается с периодом `afk`, то время `afk` должно быть "вычтено" из события. Это может привести к разделению одного исходного события на несколько более мелких, полностью "активных" фрагментов.

**Пример:**
- Событие `window`: `09:00 - 10:00`
- Событие `afk`: `09:15 - 09:30`
- Результат: Два фрагмента события `window`: `09:00 - 09:15` и `09:30 - 10:00`.

Все последующие шаги оперируют только с этими "активными" фрагментами событий.

## 4. Вторичная логика: Дробление по часам

Все "активные" фрагменты событий, полученные на шаге 3, дополнительно дробятся по границам каждого часа.

**Пример:**
- Активный фрагмент: `10:50 - 11:10`
- Результат: Два новых фрагмента: `10:50 - 11:00` и `11:00 - 11:10`.

## 5. Итоговые структуры данных

На основе обработанных фрагментов событий создаются два независимых объекта.

### 5.1. Структура 1: Временное представление (`time_view`)

- **Назначение:** Понять, что происходило в конкретный промежуток времени.
- **Структура:** Вложенный объект `Год -> Месяц -> Неделя -> День -> Час`.
- **Содержимое:** В каждом `Часе` находится массив, содержащий все фрагменты событий `window` и `stopwatch`, попадающие в этот час.

### 5.2. Структура 2: Представление по задачам (`task_view`)

- **Назначение:** Проанализировать, из какой деятельности состояла конкретная задача.
- **Структура:** Вложенный объект `Название Задачи -> Год -> Месяц -> Неделя -> День -> Час`.
- **Ключ "Название Задачи":** Берется из поля `data.label` события в `stopwatch`.
- **Содержимое:** В каждом `Часе` находится массив, содержащий только те фрагменты событий `window`, которые произошли **во время** выполнения данной задачи в данный час. Для этого вычисляется временное пересечение между фрагментами `window` и `stopwatch`.

## 6. Расширяемость

Архитектура должна быть спроектирована с учетом возможного добавления в будущем новых типов событий (например, `aw-watcher-vscode`, `aw-watcher-input`).

- **Обработка:** Новые типы событий будут проходить те же этапы обработки, что и `window` события: фильтрацию по `not-afk` интервалам и последующее дробление по часам.
- **Интеграция в структуры:**
    - В `time_view`: Фрагменты новых событий будут добавляться в массив в соответствующем `Часе` наравне с `window` и `stopwatch` событиями.
    - В `task_view`: Фрагменты новых событий (если они релевантны для анализа задач, как, например, `vscode`) будут добавляться в массив в соответствующем `Часе` наравне с `window` событиями.

Для получения исходных данных с сервера предлагается следующий подход:

Клиентское приложение определяет интересующий период времени (например, один день) и запрашивает у сервера ActivityWatch *все* события из ключевых бакетов (`aw-watcher-afk`, `aw-watcher-window`, `aw-stopwatch`) за этот период. Для этого используются параметры `start_time` и `end_time`.

## 8. Визуализация и UI

На основе обработанных данных планируется создание двух основных представлений.

### 8.1. Приоритет 1: Детальный вид дня (Почасовая шкала)

Вместо единой длинной временной шкалы, для детального анализа дня будет использоваться вертикальный стек из нескольких **часовых блоков**. Каждый такой блок соответствует одному активному часу и содержит **несколько параллельных шкал (дорожек)**, как минимум для `задач` (stopwatch) и `приложений` (window). Это решает проблему горизонтальной прокрутки и упрощает сравнение активностей между часами.

### 8.2. Приоритет 2: Обзорный вид (Календарь)

Для обзора статистики за месяц будет использоваться вид календаря. Каждая ячейка дня в календаре будет отображать сводную информацию:

- Время начала и конца работы.
- "Чистая" (not-afk) и "грязная" (от первого до последнего события) продолжительность дня.
- Список задач и их продолжительности.
- Список основных использованных приложений и их продолжительности.
- Почасовая гистограмма активности (массив из 24 чисел).

### 8.3. Необходимый шаг: Агрегация данных

Для создания календарного вида требуется дополнительный шаг обработки после основного дробления событий. Этот шаг — **агрегация** — будет вычислять сводную статистику для каждого дня и формировать из нее новый объект `daily_summary`.

---

## Журнал работ

### 2025-10-04: Настройка конвейера данных
**Проблема:** Не было способа получать данные с сервера для их последующей обработки.
**Решение:** Создана заглушка для загрузки данных из API в приложение.

### 2025-10-04: Динамический поиск ID бакетов
**Проблема:** Жестко заданные ID бакетов приводили к ошибкам, если имя хоста отличалось от ожидаемого.
**Решение:** Вместо жесткого кодирования внедрен динамический поиск. Приложение теперь само находит нужные ID бакетов по их типу (`client`), что делает систему устойчивой к изменениям окружения.
