В этом файле я планирую сохранять важную информацию (ключевые решения, выводы), к которой агент может обращаться по мере необходимости.

я не уверен, в каком финальном виде будут использоваться результаты текущей разработки, но мне нужно проверить пару теорий про анализ и юикс.
Итак, задача. Активити вотч собирает статистику и я хочу ее анализировать.
Есть три основных бакета: aw-watcher-window, aw-watcher-afk, aw-stopwatch. Второстепенные (aw-watcher-vscode, aw-watcher-input, aw-watcher-systeminfo) мне пока не интересны, но суть аналогична и их добавление должно быть простым в будущем.
Вотчеры трех основных бакетов собирают ивенты в естественной форме: их начало и конец определены натуральным образом. Мне же нужно дробить и агрегировать.

Например, мне может понадобиться видеть данные за определенный час. Но некоторые ивенты длятся дольше. Если ивент начался до часа Икс, то я хочу видеть лишь соответствующую долю продолжительности. Значит нужно дробить все ивенты дня на 24 группы длиной по часу.
Второй пример: я начинаю день (пробуждаю комп из гибернации) в условные 8 часов утра. В этот момент актвити вотч завершает ивент афк, который начат вчера за некоторое время до гибернации, и начинает новый ивент Нот-афк. Так вот, очень важно в итоговый вывод помещать время начала и конца рабочего дня (начало первого и конец последнего нотафк ивента). Эта границы должны быть использованы в том числе и в разбиении ивентов виндоу и стопвотч. если всю ночь на компе был активен например рабочий стол или иное окно, время от полуночи до начала моего рабочего дня не должно попасть в результат.
Итого у нас уже есть два набора для дробления: по часам и по попаданию в рабочий день. Но есть и третий: ивенты стопвотч это задачи, такие как Работа над проектом А, кодинг фичи Б и тому подобное. И надо разбивать ивенты виндоу еще и по задачам, тк мне может понадобиться увидеть, как долго было актвно окно Икс в задаче А.
Я не знаю, какую архитектуру выбрать. Вижу две опиции:
1. Единый список мелко порубленных ивентов бакета, разбитый не только по часам, но и по границам задач.
2. Два или три списка: 
	- ивенты, разбтые по часам
	- ивенты, разбтые по задачам
	- ивенты, разбтые по попаданию в рабочий день.

Очевидно, нужна и последующая агрегация, когда я хочу увидеть сумму продолжительностей ивентов за определенный час, день, месяц или за задачу.

кажется я понял что нужно. мне не нужна сложная агрегация по часам и по задачам одновременно, это будут две независимых формы отображения статистики. нужно два списка а точнее объекта.
первый это по времени:
время: ивенты виндоу и ивенты стопвотч (эта форма нужна если нужно понять что я делал)
второй по стопвотчу
задача: время: ивенты виндоу (эта форма нужна для анализа, чем была заполнена задача)
где
время - это вложенные год, месяц, неделя, день, час.
задача - это ивент стопвотч

при этом всем нужно учитывать лишь время нот-афк. нужно фильтровать и обрезать ивенты виндоу и стопвотч по ивентам афк.

думаю надо представить день так: делаем не один таймлайн, а вертикальный стек из 24 таймлайнов, но на самом деле меньше, тк часы без активности мы не будем показывать. вторым приоритетом надо сделать календарный вид месяца, где будем отображать статистику каждого дня: время начала и конца работы, две продолжительности дня - нот-афк и грязная, число задач, названия задач и их продолжительности (тоже грязная и чистая), число окон, названия окон и их продолжительности, почасовая активность (до 24 величин от 0 до 60 минут). как думаешь?

---

# Итоговая спецификация обработки данных

# Спецификация обработки данных ActivityWatch

## 1. Цель

Проанализировать данные из ActivityWatch, преобразовав их в две структурированные модели для дальнейшей визуализации и анализа.

## 2. Входные данные

- `aw-watcher-afk.json`: события статуса пользователя (afk, not-afk).
- `aw-watcher-window.json`: события активного окна приложения.
- `aw-stopwatch.json`: события таймера задач, определяемые пользователем.

## 3. Ключевая логика: Фильтрация по активности (AFK)

Это основной и самый важный этап обработки.

1.  Из `aw-watcher-afk.json` формируется список всех временных интервалов, когда пользователь имел статус **`not-afk`**. Эти интервалы представляют "активное время".
2.  Каждое событие из `aw-watcher-window.json` и `aw-stopwatch.json` должно быть отфильтровано и обрезано в соответствии с интервалами "активного времени".
3.  Если событие (например, использование приложения) пересекается с периодом `afk`, то время `afk` должно быть "вычтено" из события. Это может привести к разделению одного исходного события на несколько более мелких, полностью "активных" фрагментов.

**Пример:**
- Событие `window`: `09:00 - 10:00`
- Событие `afk`: `09:15 - 09:30`
- Результат: Два фрагмента события `window`: `09:00 - 09:15` и `09:30 - 10:00`.

Все последующие шаги оперируют только с этими "активными" фрагментами событий.

## 4. Вторичная логика: Дробление по часам

Все "активные" фрагменты событий, полученные на шаге 3, дополнительно дробятся по границам каждого часа.

**Пример:**
- Активный фрагмент: `10:50 - 11:10`
- Результат: Два новых фрагмента: `10:50 - 11:00` и `11:00 - 11:10`.

## 5. Итоговые структуры данных

На основе обработанных фрагментов событий создаются два независимых объекта.

### 5.1. Структура 1: Временное представление (`time_view`)

- **Назначение:** Понять, что происходило в конкретный промежуток времени.
- **Структура:** Вложенный объект `Год -> Месяц -> Неделя -> День -> Час`.
- **Содержимое:** В каждом `Часе` находится массив, содержащий все фрагменты событий `window` и `stopwatch`, попадающие в этот час.

### 5.2. Структура 2: Представление по задачам (`task_view`)

- **Назначение:** Проанализировать, из какой деятельности состояла конкретная задача.
- **Структура:** Вложенный объект `Название Задачи -> Год -> Месяц -> Неделя -> День -> Час`.
- **Ключ "Название Задачи":** Берется из поля `data.label` события в `stopwatch`.
- **Содержимое:** В каждом `Часе` находится массив, содержащий только те фрагменты событий `window`, которые произошли **во время** выполнения данной задачи в данный час. Для этого вычисляется временное пересечение между фрагментами `window` и `stopwatch`.

## 6. Расширяемость

Архитектура должна быть спроектирована с учетом возможного добавления в будущем новых типов событий (например, `aw-watcher-vscode`, `aw-watcher-input`).

- **Обработка:** Новые типы событий будут проходить те же этапы обработки, что и `window` события: фильтрацию по `not-afk` интервалам и последующее дробление по часам.
- **Интеграция в структуры:**
    - В `time_view`: Фрагменты новых событий будут добавляться в массив в соответствующем `Часе` наравне с `window` и `stopwatch` событиями.
    - В `task_view`: Фрагменты новых событий (если они релевантны для анализа задач, как, например, `vscode`) будут добавляться в массив в соответствующем `Часе` наравне с `window` событиями.

Для получения исходных данных с сервера предлагается следующий подход:

Клиентское приложение определяет интересующий период времени (например, один день) и запрашивает у сервера ActivityWatch *все* события из ключевых бакетов (`aw-watcher-afk`, `aw-watcher-window`, `aw-stopwatch`) за этот период. Для этого используются параметры `start_time` и `end_time`.

## 8. Визуализация и UI

На основе обработанных данных планируется создание двух основных представлений.

### 8.1. Приоритет 1: Детальный вид дня (Почасовая шкала)

Вместо единой длинной временной шкалы, для детального анализа дня будет использоваться вертикальный стек из нескольких **часовых блоков**. Каждый такой блок соответствует одному активному часу и содержит **несколько параллельных шкал (дорожек)**, как минимум для `задач` (stopwatch) и `приложений` (window). Это решает проблему горизонтальной прокрутки и упрощает сравнение активностей между часами.

### 8.2. Приоритет 2: Обзорный вид (Календарь)

Для обзора статистики за месяц будет использоваться вид календаря. Каждая ячейка дня в календаре будет отображать сводную информацию:

- Время начала и конца работы.
- "Чистая" (not-afk) и "грязная" (от первого до последнего события) продолжительность дня.
- Список задач и их продолжительности.
- Список основных использованных приложений и их продолжительности.
- Почасовая гистограмма активности (массив из 24 чисел).

### 8.3. Необходимый шаг: Агрегация данных

Для создания календарного вида требуется дополнительный шаг обработки после основного дробления событий. Этот шаг — **агрегация** — будет вычислять сводную статистику для каждого дня и формировать из нее новый объект `daily_summary`.

## 9. Принципы дизайна

- **Стиль:** Минимализм, флэт-дизайн. Основной контент отображается в виде "карточек" на светло-сером фоне.
- **Референс:** `input/interactive_spanish_cheatsheet/style.css`.
- **Палитра (из референса):**
  - Фон страницы: `#f0f0f0`
  - Фон карточек: `#ffffff`
  - Рамка: `#ccc`
  - Тень: `rgba(0,0,0,0.1)`
  - Основной текст: `#212529`
  - Второстепенный текст: `#6c757d`

---

## Журнал работ

### 2025-10-04: Настройка конвейера данных
**Проблема:** Не было способа получать данные с сервера для их последующей обработки.
**Решение:** Создана заглушка для загрузки данных из API в приложение.

### 2025-10-04: Динамический поиск ID бакетов
**Проблема:** Жестко заданные ID бакетов приводили к ошибкам, если имя хоста отличалось от ожидаемого.
**Решение:** Вместо жесткого кодирования внедрен динамический поиск. Приложение теперь само находит нужные ID бакетов по их типу (`client`), что делает систему устойчивой к изменениям окружения.

### 2025-10-04: Реализация конвейера обработки данных
**Проблема:** Необработанные данные от ActivityWatch были непригодны для анализа и визуализации. Отсутствовала структура, фильтрация по активности пользователя и связь между разными типами событий.
**Решение:** Реализован конвейер обработки, который преобразует исходные события в две иерархические модели данных (`time_view` и `task_view`). Конвейер отсекает неактивное время, дробит события по часам и агрегирует их для последующего анализа.

### 2025-10-05: Оптимизация производительности
**Проблема:** Медленная работа из-за блокировки интерфейса и загрузки избыточных данных.
**Решение:** Обработка вынесена в фон (Web Worker), API-запрос исправлен для загрузки только нужного диапазона данных.

### 2025-10-05: Повышение надежности конвейера данных
**Проблема:** Некорректные данные от `aw-watcher-afk` (пересекающиеся `not-afk` интервалы) приводили к созданию дубликатов событий, что вызывало ложные ошибки на последующих этапах.
**Решение:** В начало конвейера добавлена процедура очистки и слияния именно `not-afk` интервалов. Это устранило первопричину дубликатов и сделало обработку устойчивой к некорректным данным от AFK-вотчера.

### 2025-10-05: Анализ чистоты данных
**Проблема:** Существовала гипотеза, что в исходных данных могут присутствовать пересекающиеся по времени события окон или задач, что могло бы исказить результаты анализа.
**Решение:** В конвейер обработки добавлены функции для анализа пересечений. Анализ показал, что в текущих данных такие пересечения отсутствуют. Принято решение оставить эти функции в качестве пассивных предохранителей.

### 2025-10-05: Реализация базового визуального стиля
**Проблема:** Отсутствовал единый визуальный стиль интерфейса, что делало его непривлекательным и сложным для восприятия.
**Решение:** На основе предоставленного пользователем референса был определен и реализован основной стиль: минимализм, флэт-дизайн, светлая "карточная" тема.

### 2025-10-05: Исправление сортировки отображения данных
**Проблема:** Неинтуитивный, смешанный порядок отображения данных: часовые блоки сортировались по возрастанию, а события внутри них — по убыванию.
**Решение:** Проведен анализ, который показал, что сервер отдает события от новых к старым, и этот порядок сохраняется при обработке. Для предсказуемости решено внедрить принудительную сортировку данных непосредственно в UI-компонентах.

### 2025-10-08: Динамический выбор дня для анализа
**Проблема:** Данные для анализа были жестко привязаны к одной конкретной дате, что делало невозможным просмотр статистики за другие дни.
**Решение:** Внедрен интерактивный выбор даты. Приложение теперь динамически загружает и отображает данные для любого выбранного пользователем дня, по умолчанию используя текущую дату.

### 2025-10-08: Реализация параллельных дорожек в детальном виде
**Проблема:** Все типы событий отображались в одной смешанной временной шкале, что мешало анализу.
**Решение:** Визуализация разделена на параллельные дорожки. Теперь задачи и использованные приложения отображаются на отдельных, независимых шкалах для каждого часа.

### 2025-10-08: Устранение визуального шума и улучшение детализации
**Проблема:** На временной шкале возникал "визуальный шум" из-за множества коротких событий, что мешало анализу. Попытки сгруппировать их приводили к ошибкам и потере данных.
**Решение:** Реализована двухуровневая система визуализации. На основной "агрегированной" дорожке короткие события теперь группируются в единые блоки. На параллельной "детальной" дорожке отображаются все исходные события, что позволяет проводить как высокоуровневый, так и подробный анализ без потери данных.

### 2025-10-11: Повышение информативности всплывающих подсказок
**Проблема:** Всплывающие подсказки для сгруппированных событий были недостаточно информативны, показывая лишь общую сводку по приложениям.
**Решение:** Подсказки были переработаны для отображения двухуровневой информации: к общей сводке по приложениям добавлен детальный список всех исходных событий, включая их заголовки и длительность. Это позволяет быстро анализировать содержимое агрегированных блоков без необходимости обращаться к детальной дорожке.

### 2025-10-11: Глубокий рефакторинг конвейера данных и UI
**Проблема:** Архитектура обработки данных была хрупкой: UI-компоненты выполняли сложную логику по "расшифровке" данных, что приводило к каскадным ошибкам.
**Решение:** Проведен полный рефакторинг конвейера данных. Логика была централизована и изолирована: теперь обработчик готовит независимые потоки данных для детального и агрегированного вида. В ходе работ было исправлено использование фоновой обработки (Web Worker) и устранены сопутствующие регрессии, что в итоге сделало архитектуру надежной и предсказуемой.

### 2025-10-11: Рефакторинг и уплотнение UI
**Проблема:** Первоначальный макет отображения данных по часам был слишком громоздким, с большими отступами и множеством заголовков, что мешало обзору.
**Решение:** Проведен рефакторинг UI-компонентов. Логика отображения была централизована, что позволило создать новый, значительно более компактный и минималистичный макет. Все дорожки таймлайнов для каждого часа теперь сгруппированы вместе без лишних подписей, а детали доступны в едином компактном спойлере.

### 2025-10-11: Санация заголовков событий
**Проблема:** Заголовки событий содержали "мусорные" данные (маркеры несохраненных файлов, названия приложений), что ухудшало читаемость.
**Решение:** В конвейер обработки данных добавлен механизм очистки заголовков. Он удаляет лишние символы и стандартные суффиксы приложений на основе набора настраиваемых правил, делая заголовки чистыми и информативными.

### 2025-10-11: Сводка по часу
**Проблема:** Отсутствовал быстрый способ оценить, на что было потрачено время в течение часа, без анализа списка отдельных событий.
**Решение:** Добавлена сводка для каждого часа, показывающая суммарное время, процент и разбивку по задачам и приложениям. Для сохранения отзывчивости интерфейса все вычисления были вынесены в фоновый Web Worker.

### 2025-10-11: Визуализация сводок и учет AFK
**Проблема:** Отсутствовала наглядная визуализация распределения времени в течение часа
**Решение:** Добавлены почасовые гистограммы (stacked bar charts), показывающие распределение времени по приложениям и заголовкам. Реализован расчет AFK-времени и его включение в гистограммы. Добавлен переключатель в интерфейсе для возможности скрыть AFK из сводок.

### 2025-10-11: Устранение разрывов в данных о событиях
**Проблема:** Обнаружены многочисленные короткие разрывы во времени между последовательными событиями, что приводило к неполному учету времени активности.
**Решение:** Реализован механизм "лечения" данных, который заполняет короткие разрывы (до 10 секунд) в `not-afk` сессиях, продлевая длительность предыдущего события. Это обеспечивает более точный и непрерывный учет времени.

### 2025-10-11: Реализация подсветки одинаковых событий
**Проблема:** Отсутствовала возможность быстро найти все одинаковые события на временной шкале.
**Решение:** Добавлена подсветка всех событий с одинаковым именем при наведении курсора. Реализация использует Svelte store и CSS-переменные для обеспечения плавной анимации. К сожалению плавной работы добиться не удалось.

### 2025-10-11: Расширение подсветки на гистограммы
**Проблема:** Подсветка одинаковых событий работала только на временных шкалах и не затрагивала гистограммы почасовых сводок.
**Решение:** Централизована логика идентификации событий. Теперь уникальный идентификатор генерируется на этапе обработки данных и используется всеми UI-компонентами, обеспечивая сквозную подсветку.

event-bar и timeline-track имели серый фон и зеленые элементы. Теперь имеют белый фон и серые элементы